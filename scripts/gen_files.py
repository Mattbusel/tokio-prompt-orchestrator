
import os
BASE = r"C:\Users\Matthew\Tokio Prompt\src"
os.makedirs(os.path.join(BASE, "evolution"), exist_ok=True)

def w(rel, txt):
    p = os.path.join(BASE, *rel.split("/"))
    open(p, "w").write(txt)
    print("Written:", p)

files = {}

files["self_tune/controller.rs"] = (
'//! # Parameter Controller (Task 1.2)\n'
'//! PID controllers for 12 tunable pipeline parameters.\n'
'//! Auto-rolls-back if changes degrade metrics by >10pct in 30s.\n'
'#![cfg(feature = "self-tune")]\n'
'use std::{collections::HashMap, sync::{Arc, Mutex}, time::{SystemTime, UNIX_EPOCH}};\n'
'use serde::{Deserialize, Serialize};\n'
'use std::sync::atomic::{AtomicU64, Ordering};\n'
'use thiserror::Error;\n'
'use tracing::{debug, info, warn};\n'
'/// Errors produced by the parameter controller.\n'
'#[derive(Debug, Error)]\n'
'pub enum ControllerError {\n'
'    #[error("parameter not found: \'{0}\'")]\n'
'    ParameterNotFound(String),\n'
'    #[error("rollback failed: {0}")]\n'
'    RollbackFailed(String),\n'
'    #[error("lock poisoned")]\n'
'    LockPoisoned,\n'
'}\n'
'/// Specification for a tunable pipeline parameter.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct ParameterSpec {\n'
'    pub name: String, pub min: f64, pub max: f64,\n'
'    pub step: f64, pub cooldown_secs: u64, pub rollback_threshold: f64,\n'
'}\n'
'impl ParameterSpec {\n'
'    /// Create spec with rollback_threshold defaulting to 0.10.\n'
'    pub fn new(name: &str, min: f64, max: f64, step: f64, cooldown_secs: u64) -> Self {\n'
'        Self { name: name.to_string(), min, max, step, cooldown_secs, rollback_threshold: 0.10 }\n'
'    }\n'
'}\n'
'/// PID controller state for one parameter.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct PidState {\n'
'    pub kp: f64, pub ki: f64, pub kd: f64,\n'
'    pub integral: f64, pub prev_error: f64, pub last_updated_ms: u64,\n'
'}\n'
'impl PidState {\n'
'    /// Construct with given gains.\n'
'    pub fn new(kp: f64, ki: f64, kd: f64) -> Self {\n'
'        Self { kp, ki, kd, integral: 0.0, prev_error: 0.0, last_updated_ms: 0 }\n'
'    }\n'
'    /// Compute PID output and update state.\n'
'    pub fn compute(&mut self, error: f64) -> f64 {\n'
'        self.integral += error;\n'
'        let derivative = error - self.prev_error;\n'
'        self.prev_error = error;\n'
'        self.kp * error + self.ki * self.integral + self.kd * derivative\n'
'    }\n'
'}\n'
'/// Runtime state for a managed parameter.\n'
'#[derive(Debug, Clone)]\n'
'pub struct ParameterState {\n'
'    pub spec: ParameterSpec, pub pid: PidState, pub current_value: f64,\n'
'    pub last_changed_ms: u64, pub pre_change_value: f64, pub pre_change_metric: f64,\n'
'}\n'
'/// Controller-wide configuration.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct ControllerConfig {\n'
'    pub rollback_window_secs: u64, pub enabled: bool,\n'
'    pub target_p99_latency_ms: u64, pub target_throughput_rps: f64,\n'
'}\n'
'impl Default for ControllerConfig {\n'
'    fn default() -> Self {\n'
'        Self { rollback_window_secs: 30, enabled: true, target_p99_latency_ms: 100, target_throughput_rps: 100.0 }\n'
'    }\n'
'}\n'
'/// One parameter adjustment record.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct ParameterAdjustment {\n'
'    pub parameter: String, pub old_value: f64, pub new_value: f64,\n'
'    pub reason: String, pub timestamp_ms: u64,\n'
'}\n'
'/// PID-based controller managing 12 tunable pipeline parameters.\n'
'pub struct ParameterController {\n'
'    parameters: Arc<Mutex<HashMap<String, ParameterState>>>,\n'
'    config: ControllerConfig,\n'
'    adjustment_log: Arc<Mutex<Vec<ParameterAdjustment>>>,\n'
'    total_adjustments: Arc<AtomicU64>,\n'
'    total_rollbacks: Arc<AtomicU64>,\n'
'}\n'
'fn now_ms() -> u64 {\n'
'    SystemTime::now().duration_since(UNIX_EPOCH).map(|d| d.as_millis() as u64).unwrap_or(0)\n'
'}\n'
)

files["self_tune/controller.rs"] += (
'impl ParameterController {\n'
'    /// Create controller and pre-register 12 standard parameters.\n'
'    pub fn new(config: ControllerConfig) -> Self {\n'
'        let ctrl = Self {\n'
'            parameters: Arc::new(Mutex::new(HashMap::new())), config,\n'
'            adjustment_log: Arc::new(Mutex::new(Vec::new())),\n'
'            total_adjustments: Arc::new(AtomicU64::new(0)),\n'
'            total_rollbacks: Arc::new(AtomicU64::new(0)),\n'
'        };\n'
'        ctrl.register_defaults(); ctrl\n'
'    }\n'
'    fn register_defaults(&self) {\n'
'        let defs: &[(&str, f64, f64, f64, u64)] = &[\n'
'            ("rag_channel_buffer",       64.0,   4096.0,  64.0, 10),\n'
'            ("assemble_channel_buffer",  64.0,   4096.0,  64.0, 10),\n'
'            ("inference_channel_buffer",128.0,   8192.0, 128.0, 10),\n'
'            ("post_channel_buffer",      64.0,   4096.0,  64.0, 10),\n'
'            ("stream_channel_buffer",    32.0,   2048.0,  32.0, 10),\n'
'            ("backpressure_threshold",    0.5,     0.99,   0.05, 15),\n'
'            ("circuit_breaker_threshold", 0.5,    1.0,    0.05, 30),\n'
'            ("circuit_breaker_timeout",   5.0,  300.0,    5.0,  30),\n'
'            ("dedup_ttl_secs",           30.0, 3600.0,   30.0,  60),\n'
'            ("rate_limit_rps",           10.0,10000.0,   10.0,   5),\n'
'            ("priority_high_weight",      1.0,   10.0,    0.5,  20),\n'
'            ("retry_max_attempts",        1.0,   10.0,    1.0,  30),\n'
'        ];\n'
'        for &(name, min, max, step, cooldown) in defs {\n'
'            let _ = self.register_parameter(\n'
'                ParameterSpec::new(name, min, max, step, cooldown), (min + max) / 2.0);\n'
'        }\n'
'    }\n'
'    /// Register a parameter clamped to [min, max].\n'
'    pub fn register_parameter(&self, spec: ParameterSpec, initial_value: f64) -> Result<(), ControllerError> {\n'
'        let mut params = self.parameters.lock().map_err(|_| ControllerError::LockPoisoned)?;\n'
'        let clamped = initial_value.clamp(spec.min, spec.max);\n'
'        params.insert(spec.name.clone(), ParameterState {\n'
'            pid: PidState::new(0.1, 0.01, 0.05), current_value: clamped,\n'
'            last_changed_ms: 0, pre_change_value: clamped, pre_change_metric: f64::MAX, spec,\n'
'        });\n'
'        Ok(())\n'
'    }\n'
'    /// Run one control tick, returning adjustments applied.\n'
'    pub fn tick(&self, p99_latency_ms: u64, throughput_rps: f64) -> Result<Vec<ParameterAdjustment>, ControllerError> {\n'
'        if !self.config.enabled { return Ok(Vec::new()); }\n'
'        let now = now_ms();\n'
'        let mut params = self.parameters.lock().map_err(|_| ControllerError::LockPoisoned)?;\n'
'        let mut adjustments = Vec::new();\n'
'        let lat_err = self.config.target_p99_latency_ms as f64 - p99_latency_ms as f64;\n'
'        let tput_err = throughput_rps - self.config.target_throughput_rps;\n'
'        for state in params.values_mut() {\n'
'            let cooldown_ms = state.spec.cooldown_secs * 1000;\n'
'            if state.last_changed_ms > 0 && now.saturating_sub(state.last_changed_ms) < cooldown_ms {\n'
'                debug!(param = state.spec.name.as_str(), "cooldown active"); continue;\n'
'            }\n'
'            let error = if state.spec.name.contains("channel_buffer") || state.spec.name.contains("rate_limit") {\n'
'                tput_err * 0.01\n'
'            } else { lat_err * 0.01 };\n'
'            let output = state.pid.compute(error);\n'
'            if output.abs() < 1e-9 { continue; }\n'
'            let steps = (output / state.spec.step).round();\n'
'            if steps.abs() < 1.0 { continue; }\n'
'            let new_value = (state.current_value + steps * state.spec.step).clamp(state.spec.min, state.spec.max);\n'
'            if (new_value - state.current_value).abs() < 1e-9 { continue; }\n'
'            let old_value = state.current_value;\n'
'            state.pre_change_value = old_value;\n'
'            state.pre_change_metric = p99_latency_ms as f64;\n'
'            state.current_value = new_value; state.last_changed_ms = now; state.pid.last_updated_ms = now;\n'
'            let reason = format!("PID={output:.4} lat={lat_err:.2} tput={tput_err:.2}");\n'
'            info!(param = state.spec.name.as_str(), old = old_value, new = new_value, "adjusted");\n'
'            adjustments.push(ParameterAdjustment { parameter: state.spec.name.clone(),\n'
'                old_value, new_value, reason, timestamp_ms: now });\n'
'        }\n'
'        if !adjustments.is_empty() {\n'
'            if let Ok(mut log) = self.adjustment_log.lock() {\n'
'                self.total_adjustments.fetch_add(adjustments.len() as u64, Ordering::Relaxed);\n'
'                log.extend(adjustments.iter().cloned());\n'
'            }\n'
'        }\n'
'        Ok(adjustments)\n'
'    }\n'
)

files["self_tune/controller.rs"] += (
'    /// Roll back parameters whose changes degraded metrics beyond threshold.\n'
'    pub fn check_rollbacks(&self, current_metric: f64) -> Vec<String> {\n'
'        let now = now_ms();\n'
'        let window_ms = self.config.rollback_window_secs * 1000;\n'
'        let mut params = match self.parameters.lock() { Ok(g) => g, Err(_) => return Vec::new() };\n'
'        let mut rolled = Vec::new();\n'
'        for state in params.values_mut() {\n'
'            if state.last_changed_ms == 0 { continue; }\n'
'            if now.saturating_sub(state.last_changed_ms) > window_ms { continue; }\n'
'            if state.pre_change_metric == f64::MAX { continue; }\n'
'            let threshold = state.pre_change_metric * (1.0 + state.spec.rollback_threshold);\n'
'            if current_metric > threshold {\n'
'                warn!(param = state.spec.name.as_str(), current_metric, threshold, "rolling back");\n'
'                state.current_value = state.pre_change_value;\n'
'                state.last_changed_ms = 0;\n'
'                state.pre_change_metric = f64::MAX;\n'
'                rolled.push(state.spec.name.clone());\n'
'                self.total_rollbacks.fetch_add(1, Ordering::Relaxed);\n'
'            }\n'
'        }\n'
'        rolled\n'
'    }\n'
'    /// Get the current value of a named parameter.\n'
'    pub fn get_value(&self, name: &str) -> Result<f64, ControllerError> {\n'
'        let params = self.parameters.lock().map_err(|_| ControllerError::LockPoisoned)?;\n'
'        params.get(name).map(|s| s.current_value)\n'
'            .ok_or_else(|| ControllerError::ParameterNotFound(name.to_string()))\n'
'    }\n'
'    /// Total adjustments applied since creation.\n'
'    pub fn adjustment_count(&self) -> u64 { self.total_adjustments.load(Ordering::Relaxed) }\n'
'    /// Total rollbacks performed since creation.\n'
'    pub fn rollback_count(&self) -> u64 { self.total_rollbacks.load(Ordering::Relaxed) }\n'
'}\n'
'#[cfg(test)]\n'
'mod tests {\n'
'    use super::*;\n'
'    fn ctrl() -> ParameterController { ParameterController::new(ControllerConfig::default()) }\n'
'    #[test]\n'
'    fn test_registers_12_default_parameters() { assert_eq!(ctrl().parameters.lock().unwrap().len(), 12); }\n'
'    #[test]\n'
'    fn test_register_parameter_stores_initial_value() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("p", 0.0, 100.0, 1.0, 5), 42.0).unwrap();\n'
'        assert!((c.get_value("p").unwrap() - 42.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_register_clamps_below_min() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("lo", 10.0, 100.0, 1.0, 5), -5.0).unwrap();\n'
'        assert!((c.get_value("lo").unwrap() - 10.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_register_clamps_above_max() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("hi", 0.0, 50.0, 1.0, 5), 999.0).unwrap();\n'
'        assert!((c.get_value("hi").unwrap() - 50.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_get_missing_parameter_returns_not_found() {\n'
'        assert!(matches!(ctrl().get_value("nope").unwrap_err(), ControllerError::ParameterNotFound(_)));\n'
'    }\n'
'    #[test]\n'
'    fn test_tick_disabled_returns_empty() {\n'
'        let c = ParameterController::new(ControllerConfig { enabled: false, ..Default::default() });\n'
'        assert!(c.tick(9999, 0.001).unwrap().is_empty());\n'
'    }\n'
'    #[test]\n'
'    fn test_tick_no_panic_on_extreme_values() { ctrl().tick(u64::MAX, f64::MAX).unwrap(); }\n'
'    #[test]\n'
'    fn test_check_rollbacks_empty_when_no_changes() { assert!(ctrl().check_rollbacks(9999.0).is_empty()); }\n'
'    #[test]\n'
'    fn test_rollback_triggers_on_degradation() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("rb", 0.0, 100.0, 1.0, 0), 50.0).unwrap();\n'
'        { let mut p = c.parameters.lock().unwrap(); let s = p.get_mut("rb").unwrap();\n'
'          s.pre_change_value = 40.0; s.pre_change_metric = 100.0; s.last_changed_ms = now_ms(); }\n'
'        assert!(c.check_rollbacks(300.0).contains(&"rb".to_string()));\n'
'    }\n'
'    #[test]\n'
'    fn test_rollback_restores_previous_value() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("rv", 0.0, 100.0, 1.0, 0), 70.0).unwrap();\n'
'        { let mut p = c.parameters.lock().unwrap(); let s = p.get_mut("rv").unwrap();\n'
'          s.pre_change_value = 50.0; s.pre_change_metric = 100.0; s.last_changed_ms = now_ms(); }\n'
'        c.check_rollbacks(300.0);\n'
'        assert!((c.get_value("rv").unwrap() - 50.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_rollback_count_increments() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("rc", 0.0, 100.0, 1.0, 0), 50.0).unwrap();\n'
'        { let mut p = c.parameters.lock().unwrap(); let s = p.get_mut("rc").unwrap();\n'
'          s.pre_change_metric = 100.0; s.last_changed_ms = now_ms(); }\n'
'        c.check_rollbacks(500.0);\n'
'        assert_eq!(c.rollback_count(), 1);\n'
'    }\n'
'    #[test]\n'
'    fn test_pid_proportional() {\n'
'        let mut pid = PidState::new(2.0, 0.0, 0.0);\n'
'        assert!((pid.compute(5.0) - 10.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_pid_integral_accumulates() {\n'
'        let mut pid = PidState::new(0.0, 1.0, 0.0); pid.compute(3.0);\n'
'        assert!((pid.compute(3.0) - 6.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_pid_derivative_direction() {\n'
'        let mut pid = PidState::new(0.0, 0.0, 1.0); pid.compute(10.0);\n'
'        assert!((pid.compute(5.0) - (-5.0)).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_parameter_spec_default_rollback_threshold() {\n'
'        assert!((ParameterSpec::new("t", 0.0, 1.0, 0.1, 1).rollback_threshold - 0.10).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_cooldown_prevents_adjustment() {\n'
'        let c = ctrl();\n'
'        c.register_parameter(ParameterSpec::new("cd", 0.0, 100.0, 1.0, 9999), 10.0).unwrap();\n'
'        { let mut p = c.parameters.lock().unwrap(); p.get_mut("cd").unwrap().last_changed_ms = now_ms(); }\n'
'        assert!(!c.tick(9999, 0.001).unwrap().iter().any(|a| a.parameter == "cd"));\n'
'    }\n'
'    #[test]\n'
'    fn test_default_config_values() {\n'
'        let cfg = ControllerConfig::default();\n'
'        assert_eq!(cfg.rollback_window_secs, 30); assert!(cfg.enabled);\n'
'        assert_eq!(cfg.target_p99_latency_ms, 100);\n'
'    }\n'
'}\n'
)

files["self_modify/deploy.rs"] = (
'//! # Staged Deployment Pipeline (Task 2.4)\n'
'//! Blue-green deployment with canary testing and automatic rollback.\n'
'//! Routes traffic: canary (5pct) -> 25pct -> 50pct -> 100pct.\n'
'#![cfg(feature = "self-modify")]\n'
'use std::sync::{Arc, Mutex};\n'
'use std::sync::atomic::{AtomicU64, Ordering};\n'
'use serde::{Deserialize, Serialize};\n'
'use thiserror::Error;\n'
'use tracing::{info, warn};\n'
'use std::time::{SystemTime, UNIX_EPOCH};\n'
'/// Errors produced by the deployment pipeline.\n'
'#[derive(Debug, Error)]\n'
'pub enum DeployError {\n'
'    #[error("canary failed: {0}")]\n'
'    CanaryFailed(String),\n'
'    #[error("rollback failed: {0}")]\n'
'    RollbackFailed(String),\n'
'    #[error("metric check failed: {0}")]\n'
'    MetricCheckFailed(String),\n'
'    #[error("lock poisoned")]\n'
'    LockPoisoned,\n'
'}\n'
'/// Deployment progression stage.\n'
'#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\n'
'pub enum DeployStage { Canary, Quarter, Half, Full, RolledBack }\n'
'/// Configuration for the deployment pipeline.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct DeploymentConfig {\n'
'    pub canary_traffic_pct: f64,\n'
'    pub monitor_secs: u64,\n'
'    pub regression_threshold: f64,\n'
'    pub auto_rollback: bool,\n'
'}\n'
'impl Default for DeploymentConfig {\n'
'    fn default() -> Self {\n'
'        Self { canary_traffic_pct: 0.05, monitor_secs: 300, regression_threshold: 0.05, auto_rollback: true }\n'
'    }\n'
'}\n'
'/// Record of a single deployment operation.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct DeploymentRecord {\n'
'    pub id: String,\n'
'    pub change_description: String,\n'
'    pub stage: DeployStage,\n'
'    pub started_at_ms: u64,\n'
'    pub completed_at_ms: Option<u64>,\n'
'    pub baseline_p99_ms: f64,\n'
'    pub canary_p99_ms: Option<f64>,\n'
'    pub outcome: Option<String>,\n'
'}\n'
'/// Blue-green deployer with canary gating and auto-rollback.\n'
'pub struct Deployer {\n'
'    config: DeploymentConfig,\n'
'    active: Arc<Mutex<Option<DeploymentRecord>>>,\n'
'    history: Arc<Mutex<Vec<DeploymentRecord>>>,\n'
'    total_deployments: Arc<AtomicU64>,\n'
'    total_rollbacks: Arc<AtomicU64>,\n'
'}\n'
'fn now_ms() -> u64 {\n'
'    SystemTime::now().duration_since(UNIX_EPOCH).map(|d| d.as_millis() as u64).unwrap_or(0)\n'
'}\n'
'fn new_id() -> String {\n'
'    format!("deploy-{}", now_ms())\n'
'}\n'
)

files["self_modify/deploy.rs"] += (
'impl Deployer {\n'
'    pub fn new(config: DeploymentConfig) -> Self {\n'
'        Self { config, active: Arc::new(Mutex::new(None)),\n'
'            history: Arc::new(Mutex::new(Vec::new())),\n'
'            total_deployments: Arc::new(AtomicU64::new(0)),\n'
'            total_rollbacks: Arc::new(AtomicU64::new(0)) }\n'
'    }\n'
'    pub fn begin(&self, change_description: &str, baseline_p99_ms: f64) -> Result<String, DeployError> {\n'
'        let mut active = self.active.lock().map_err(|_| DeployError::LockPoisoned)?;\n'
'        if active.is_some() { return Err(DeployError::CanaryFailed("deployment already active".to_string())); }\n'
'        let id = new_id();\n'
'        *active = Some(DeploymentRecord { id: id.clone(),\n'
'            change_description: change_description.to_string(), stage: DeployStage::Canary,\n'
'            started_at_ms: now_ms(), completed_at_ms: None, baseline_p99_ms,\n'
'            canary_p99_ms: None, outcome: None });\n'
'        self.total_deployments.fetch_add(1, Ordering::Relaxed);\n'
'        info!(id = id.as_str(), "deployment started"); Ok(id)\n'
'    }\n'
'    pub fn advance_stage(&self, current_p99_ms: f64) -> Result<DeployStage, DeployError> {\n'
'        let mut active = self.active.lock().map_err(|_| DeployError::LockPoisoned)?;\n'
'        let record = active.as_mut().ok_or_else(|| DeployError::MetricCheckFailed("no active deployment".to_string()))?;\n'
'        let limit = record.baseline_p99_ms * (1.0 + self.config.regression_threshold);\n'
'        if current_p99_ms > limit {\n'
'            warn!(p99 = current_p99_ms, "regression detected");\n'
'            if self.config.auto_rollback {\n'
'                record.stage = DeployStage::RolledBack;\n'
'                record.completed_at_ms = Some(now_ms());\n'
'                record.outcome = Some(format!("auto-rollback: p99={current_p99_ms} > limit={limit}"));\n'
'                let done = record.clone(); *active = None;\n'
'                self.history.lock().map_err(|_| DeployError::LockPoisoned)?.push(done);\n'
'                self.total_rollbacks.fetch_add(1, Ordering::Relaxed);\n'
'                return Ok(DeployStage::RolledBack);\n'
'            }\n'
'        }\n'
'        let next = match record.stage {\n'
'            DeployStage::Canary => { record.canary_p99_ms = Some(current_p99_ms); DeployStage::Quarter }\n'
'            DeployStage::Quarter => DeployStage::Half,\n'
'            DeployStage::Half => DeployStage::Full,\n'
'            DeployStage::Full | DeployStage::RolledBack => {\n'
'                record.completed_at_ms = Some(now_ms());\n'
'                record.outcome = Some("completed".to_string());\n'
'                let done = record.clone(); *active = None;\n'
'                self.history.lock().map_err(|_| DeployError::LockPoisoned)?.push(done);\n'
'                return Ok(DeployStage::Full);\n'
'            }\n'
'        };\n'
'        record.stage = next.clone();\n'
'        if next == DeployStage::Full {\n'
'            record.completed_at_ms = Some(now_ms());\n'
'            record.outcome = Some("completed".to_string());\n'
'            let done = record.clone(); *active = None;\n'
'            self.history.lock().map_err(|_| DeployError::LockPoisoned)?.push(done);\n'
'        }\n'
'        info!(stage = format!("{:?}", next).as_str(), "stage advanced");\n'
'        Ok(next)\n'
'    }\n'
'    pub fn rollback(&self, reason: &str) -> Result<(), DeployError> {\n'
'        let mut active = self.active.lock().map_err(|_| DeployError::LockPoisoned)?;\n'
'        let record = active.as_mut().ok_or_else(|| DeployError::RollbackFailed("no active deployment".to_string()))?;\n'
'        record.stage = DeployStage::RolledBack;\n'
'        record.completed_at_ms = Some(now_ms());\n'
'        record.outcome = Some(format!("manual rollback: {reason}"));\n'
'        let done = record.clone(); *active = None;\n'
'        self.history.lock().map_err(|_| DeployError::LockPoisoned)?.push(done);\n'
'        self.total_rollbacks.fetch_add(1, Ordering::Relaxed);\n'
'        warn!(reason, "deployment rolled back"); Ok(())\n'
'    }\n'
'    pub fn active_deployment(&self) -> Option<DeploymentRecord> {\n'
'        self.active.lock().ok()?.as_ref().cloned()\n'
'    }\n'
'    pub fn recent_deployments(&self, n: usize) -> Vec<DeploymentRecord> {\n'
'        match self.history.lock() { Ok(h) => h.iter().rev().take(n).cloned().collect(), Err(_) => Vec::new() }\n'
'    }\n'
'    pub fn total_deployments(&self) -> u64 { self.total_deployments.load(Ordering::Relaxed) }\n'
'    pub fn total_rollbacks(&self) -> u64 { self.total_rollbacks.load(Ordering::Relaxed) }\n'
'    pub fn traffic_fraction(stage: &DeployStage) -> f64 {\n'
'        match stage { DeployStage::Canary => 0.05, DeployStage::Quarter => 0.25,\n'
'            DeployStage::Half => 0.5, DeployStage::Full => 1.0, DeployStage::RolledBack => 0.0 }\n'
'    }\n'
'}\n'
)

files["self_modify/deploy.rs"] += (
'#[cfg(test)]\n'
'mod tests {\n'
'    use super::*;\n'
'    fn d() -> Deployer { Deployer::new(DeploymentConfig::default()) }\n'
'    #[test]\n'
'    fn test_begin_sets_active_deployment() {\n'
'        let dep = d();\n'
'        dep.begin("test change", 100.0).unwrap();\n'
'        assert!(dep.active_deployment().is_some());\n'
'    }\n'
'    #[test]\n'
'    fn test_begin_increments_total_deployments() {\n'
'        let dep = d();\n'
'        dep.begin("c1", 100.0).unwrap();\n'
'        assert_eq!(dep.total_deployments(), 1);\n'
'    }\n'
'    #[test]\n'
'    fn test_begin_fails_if_deployment_already_active() {\n'
'        let dep = d();\n'
'        dep.begin("first", 100.0).unwrap();\n'
'        assert!(dep.begin("second", 100.0).is_err());\n'
'    }\n'
'    #[test]\n'
'    fn test_advance_canary_to_quarter() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        let stage = dep.advance_stage(100.0).unwrap();\n'
'        assert_eq!(stage, DeployStage::Quarter);\n'
'    }\n'
'    #[test]\n'
'    fn test_advance_through_all_stages() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        dep.advance_stage(99.0).unwrap();\n'
'        dep.advance_stage(99.0).unwrap();\n'
'        let stage = dep.advance_stage(99.0).unwrap();\n'
'        assert_eq!(stage, DeployStage::Full);\n'
'    }\n'
'    #[test]\n'
'    fn test_advance_auto_rollback_on_regression() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        let stage = dep.advance_stage(999.0).unwrap();\n'
'        assert_eq!(stage, DeployStage::RolledBack);\n'
'    }\n'
'    #[test]\n'
'    fn test_auto_rollback_increments_rollback_count() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        dep.advance_stage(999.0).unwrap();\n'
'        assert_eq!(dep.total_rollbacks(), 1);\n'
'    }\n'
'    #[test]\n'
'    fn test_manual_rollback_clears_active() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        dep.rollback("test reason").unwrap();\n'
'        assert!(dep.active_deployment().is_none());\n'
'    }\n'
'    #[test]\n'
'    fn test_recent_deployments_returns_history() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        dep.rollback("done").unwrap();\n'
'        assert_eq!(dep.recent_deployments(10).len(), 1);\n'
'    }\n'
'    #[test]\n'
'    fn test_traffic_fraction_canary_is_005() {\n'
'        assert!((Deployer::traffic_fraction(&DeployStage::Canary) - 0.05).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_traffic_fraction_rolled_back_is_zero() {\n'
'        assert!((Deployer::traffic_fraction(&DeployStage::RolledBack) - 0.0).abs() < 1e-9);\n'
'    }\n'
'    #[test]\n'
'    fn test_full_pipeline_ends_with_no_active() {\n'
'        let dep = d();\n'
'        dep.begin("c", 100.0).unwrap();\n'
'        dep.advance_stage(99.0).unwrap();\n'
'        dep.advance_stage(99.0).unwrap();\n'
'        dep.advance_stage(99.0).unwrap();\n'
'        assert!(dep.active_deployment().is_none());\n'
'    }\n'
'}\n'
)

files["evolution/mod.rs"] = (
'//! # Distributed Evolution (Phase 4)\n'
'//!\n'
'//! - [`brain`]    - distributed consensus on self-tuning decisions\n'
'//! - [`search`]   - evolutionary parameter search (population-based)\n'
'//! - [`plugin`]   - runtime plugin loading and registry\n'
'//! - [`transfer`] - cross-instance knowledge transfer (federated, opt-in)\n'
'\n'
'pub mod brain;\n'
'pub mod plugin;\n'
'pub mod search;\n'
'pub mod transfer;\n'
'\n'
'pub use brain::{Brain, BrainConfig, ClusterDecision};\n'
'pub use plugin::{Plugin, PluginConfig, PluginRegistry};\n'
'pub use search::{EvolutionConfig, Genome, Population};\n'
'pub use transfer::{KnowledgeTransfer, TransferConfig, TransferRecord};\n'
)

files["evolution/search.rs"] = (
'//! # Evolutionary Parameter Search (Task 4.2)\n'
'//! Population-based evolutionary strategy for optimal configurations.\n'
'#![cfg(feature = "evolution")]\n'
'use std::sync::{Arc, Mutex};\n'
'use std::sync::atomic::{AtomicU64, Ordering};\n'
'use serde::{Deserialize, Serialize};\n'
'use thiserror::Error;\n'
'use tracing::info;\n'
'/// Errors produced by the population search.\n'
'#[derive(Debug, Error)]\n'
'pub enum SearchError {\n'
'    #[error("empty population")]\n'
'    EmptyPopulation,\n'
'    #[error("invalid genome: {0}")]\n'
'    InvalidGenome(String),\n'
'    #[error("lock poisoned")]\n'
'    LockPoisoned,\n'
'}\n'
'/// A single gene within a genome.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct Gene {\n'
'    pub name: String,\n'
'    pub value: f64,\n'
'    pub min: f64,\n'
'    pub max: f64,\n'
'}\n'
'/// A complete parameter configuration with fitness score.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct Genome {\n'
'    pub id: String,\n'
'    pub genes: Vec<Gene>,\n'
'    pub fitness: f64,\n'
'    pub generation: u32,\n'
'    pub evaluated: bool,\n'
'}\n'
'/// Fitness function weights.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct FitnessWeights {\n'
'    pub throughput: f64,\n'
'    pub latency: f64,\n'
'    pub cost: f64,\n'
'    pub error_rate: f64,\n'
'}\n'
'impl Default for FitnessWeights {\n'
'    fn default() -> Self {\n'
'        Self { throughput: 0.3, latency: 0.3, cost: 0.2, error_rate: 0.2 }\n'
'    }\n'
'}\n'
'/// Configuration for the evolutionary search.\n'
'#[derive(Debug, Clone, Serialize, Deserialize)]\n'
'pub struct EvolutionConfig {\n'
'    pub population_size: usize,\n'
'    pub mutation_rate: f64,\n'
'    pub crossover_rate: f64,\n'
'    pub elitism_count: usize,\n'
'    pub max_generations: u32,\n'
'    pub weights: FitnessWeights,\n'
'}\n'
'impl Default for EvolutionConfig {\n'
'    fn default() -> Self {\n'
'        Self { population_size: 20, mutation_rate: 0.1, crossover_rate: 0.7,\n'
'            elitism_count: 2, max_generations: 100, weights: FitnessWeights::default() }\n'
'    }\n'
'}\n'
'/// Evolutionary population of parameter genomes.\n'
'pub struct Population {\n'
'    genomes: Arc<Mutex<Vec<Genome>>>,\n'
'    config: EvolutionConfig,\n'
'    generation: Arc<AtomicU64>,\n'
'    best_fitness: Arc<AtomicU64>,\n'
'}\n'
'fn lcg_rand(seed: &mut u64) -> f64 {\n'
'    *seed = seed.wrapping_mul(6364136223846793005).wrapping_add(1442695040888963407);\n'
'    (*seed >> 33) as f64 / u32::MAX as f64\n'
'}\n'
'fn new_id(gen: u32, idx: usize) -> String { format!("genome-g{gen}-i{idx}") }\n'
)
